Introduction to Binary Tree

A binary tree is a tree data structure in which each node can have at most two children, which are referred to as the left child and the right child.

The topmost node in a binary tree is called the root, and the bottom-most nodes are called leaves. A binary tree can be visualized as a hierarchical 
structure with the root at the top and the leaves at the bottom.

Representation of Binary Tree:
Each node in the tree contains the following:

Data
Pointer to the left child
Pointer to the right child

class Node {
public:
    int data;
    Node* left;
    Node* right;
};


Basic Operations On Binary Tree:
Inserting an element.
Removing an element.
Searching for an element.
Deletion for an element.
Traversing an element. 

Binary Tree Traversals:
Tree Traversal algorithms can be classified broadly into two categories:

Depth-First Search (DFS) Algorithms
Breadth-First Search (BFS) Algorithms

Tree Traversal using Depth-First Search (DFS) algorithm can be further classified into three categories:

Preorder Traversal (current-left-right): 
Visit the current node before visiting any nodes inside the left or right subtrees. 
Here, the traversal is root – left child – right child. It means that the root node is traversed first then its left child and finally the right child.

code :
void preorder(Node * root){
    // NLR
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    preorder(root->left);
    preorder(root->right);
}

Inorder Traversal (left-current-right): 
Visit the current node after visiting all nodes inside the left subtree but before visiting any node within the right subtree.
Here, the traversal is left child – root – right child.  It means that the left child is traversed first then its root node and finally the right child.

code :
void inorder(Node * root){
    // LNR
    if(root==NULL){
        return;
    }

    inorder(root->left);
    cout<<root->data<<" ";
    inorder(root->right);
}

Postorder Traversal (left-right-current): 
Visit the current node after visiting all the nodes of the left and right subtrees.  
Here, the traversal is left child – right child – root.  It means that the left child has traversed first then the right child and finally its root node.


code:
void postorder(Node * root){
    // LRN
    if(root==NULL){
        return;
    }
    postorder(root->left);
    postorder(root->right);
    cout<<root->data<<" ";
}


Tree Traversal using Breadth-First Search (BFS) algorithm can be further classified into one category:

Level Order Traversal:  Visit nodes level-by-level and left-to-right fashion at the same level. Here, the traversal is level-wise. 
It means that the most left child has traversed first and then the other children of the same level from left to right have traversed. 

void lvlorder(Node * root){
    queue< Node *> q;
    q.push(root);

    while (!q.empty())
    {
        Node * temp = q.front();
        q.pop();
        cout<<temp->data<<" ";
        if(temp->left){
            q.push(temp->left);
        }
        if (temp->right)
        {
            q.push(temp->right);
        }
    }
}


___________

Reverse Level order Traversal

void rlvlorder(Node *root){
    queue< Node *> q;
    stack< Node *> s;
    q.push(root);

    while (!q.empty())
    {
        Node * temp = q.front();
        q.pop();
        s.push(temp);

        if(temp->right){
            q.push(temp->right);
        }

        if(temp->left){
            q.push(temp->left);
        }
    }
    while (!s.empty())
    {
        Node * temp = s.top();
        cout<<temp->data<<" ";
        s.pop();
    } 
}
